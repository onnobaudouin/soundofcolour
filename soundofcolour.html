<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sound Of Colour</title>
    <link href="nouislider.min.css" rel="stylesheet">
    <script src="nouislider.min.js"></script>
    <script src="socketclient.js"></script>
    <script src="properties.js"></script>
    <script src="canvas2d.js"></script>
    <script src="value_to_json.js"></script>
    <script src="dat.gui.min.js"></script>
    <script src="dat_properties.js"></script>
    <script>
        function object_to_map(object) {
            let m = new Map();
            for (let key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                    m.set(key, object[key]);
                }
            }
            return m;
        }
    </script>



    <script language="javascript" type="text/javascript">
        class SoundOfColourServer extends SocketClient {

            constructor() {
                super();
                this.id = "soc_" + SoundOfColourServer.id_gen++;
                this.balls = [];
                this.resolution = {width: 0, height: 0};
                /*@var Canvas2D */
                this.canvas2d = null;
                this.img = null;
                this.show_ui = false;
                this.frame_grabber_id = null;
                this.is_grabbing_frame = false;
                this.properties_ui = null;

                this.is_sampling_colour = false;
                this.samplingStart = null;
                this.samplingCurrent = null;
                this.lastHSVHistogram = null;

            }

            connect_ui(parent_element) {
                this.setup_dom(parent_element);
                this.canvas2d = new Canvas2D(this.id_extra('canvas'));
                this.canvas2d.mouse_event_handler = (name, pos) => this.on_mouse_event(name, pos);

                this.img = document.getElementById(this.id_extra('img'));

                this.connect_button = document.getElementById(this.id_extra('connect'));
                this.connect_button.addEventListener('click', () => {
                    let ip = document.getElementById(this.id_extra('ip')).value;
                    this.url = "ws://" + ip + ":8001";
                    this.start_connect();
                });
                this.stabilize_button = document.getElementById(this.id_extra('stabilize'));
                this.stabilize_button.addEventListener('click', () => {
                    this.stabilize();
                });
                this.toggle_ui_button = document.getElementById(this.id_extra('toggle_ui'));
                this.toggle_ui_button.addEventListener('click', () => {
                    this.toggle_ui();
                });

            }

            distance(x1, y1, x2, y2) {
                const dx = x1 - x2;
                const dy = y1 - y2;
                return Math.sqrt(dx*dx + dy*dy);
            }

            on_mouse_event(event_name, position_mouse_in_canvas) {

               switch (event_name) {
                   case 'move':
                       if(this.is_sampling_colour) {
                           if (
                               (this.samplingCurrent.x !== position_mouse_in_canvas.x) ||
                               (this.samplingCurrent.y !== position_mouse_in_canvas.y) ) {

                               this.samplingCurrent = position_mouse_in_canvas;
                               const radius = this.distance(
                                    this.samplingStart.x,
                                    this.samplingStart.y,
                                    this.samplingCurrent.x,
                                    this.samplingCurrent.y);
                               this.send_message('mouse',
                                   {
                                       event: 'move', x: this.samplingCurrent.xPercent,
                                       y: this.samplingCurrent.yPercent
                                   });

                               this.send_message('sample', {
                                   event: 'histogram_hsv',
                                   x: this.samplingStart.xPercent,
                                   y: this.samplingStart.yPercent,
                                   radius: radius / position_mouse_in_canvas.width

                               })


                           }
                       } break;

                   case 'down':
                       if (!this.is_sampling_colour) {
                           this.is_sampling_colour = true;
                           this.samplingStart = position_mouse_in_canvas;
                           this.samplingCurrent = this.samplingStart;
                           this.send_message('mouse',
                               {event:'down', x:this.samplingCurrent.xPercent,
                                   y:this.samplingCurrent.yPercent});
                       }
                       break;
                   case 'up': {
                       if (this.is_sampling_colour) {
                           this.is_sampling_colour = false;

                           this.send_message('mouse',
                               {event:'up',x:position_mouse_in_canvas.xPercent,
                                   y:position_mouse_in_canvas.yPercent});
                           this.samplingStart = null;
                           this.samplingCurrent = null;
                       } break;
                   }
               }


            }

            on_close(event) {
                console.log("connection closed - killing ui...");
                this.properties_ui.destroy();
                this.properties_ui = null;

            }


            on_open(event) {

            }



            maybe_request_frame() {
                if (this.is_connected()) {
                    //console.log('request a frame');
                    if (this.is_grabbing_frame === false) {
                        this.is_grabbing_frame = true;
                        this.send_message("frame",
                            {
                                'quality': this.properties[0].value_of("frame/quality"), 'format': 'jpg', ratio: 1.0
                            });
                        return;
                    } else {
                        //console.log('Bounced');
                    }
                }
                this.is_grabbing_frame = false;
            }

            update_canvas_size(width, height) {
                this.resolution.width = width;
                this.resolution.height = height;
                this.canvas2d.update_resolution(width, height);
            }

            on_message_welcome() {
                this.send_message('prop_description')
            }



            on_message_prop_description(message) {
                let p = object_to_map(message);
                this.properties = [];
                p.forEach((value, key) => {
                    if (typeof value["type"] !== 'undefined') {
                        this.properties.push(Properties.create_from_description_object(value));
                    }
                });
                console.log(this.properties);

                let t = this.properties[0];
                let f = t.add_group('frame');
                f.add('quality', PropNodeType.unsigned_int, 50, 0, 100);

                this.frame_grabber_id = setInterval(() => this.maybe_request_frame(), 20);

                this.properties_ui = new DatGUIPropertiesView();
                this.properties_ui.from_properties(t);


                this.coloured_ball_tracker_properties = t;

            /*    console.log(t.value_of('colours/blue/enabled'));
                console.log(t.set_value_of('colours/blue/enabled', false));
                console.log(t.value_of('colours/blue/enabled'));
                let c = t.contents_json();
                console.log(c);
                console.log(t.set_value_of('colours/blue/enabled', true));
                console.log(t.value_of('colours/blue/enabled'));

                t.from_contents_json(c);
                console.log(t.value_of('colours/blue/enabled'));*/

                this.send_message('prop_all', {'properties_name': 'coloured_ball_tracker'});
            }

            on_message_prop_all(message) {
                console.log(message);
                this.coloured_ball_tracker_properties.from_contents(message);
                this.properties_ui.update(); //todo -> properties should warn a UI that it has changed...
                this.properties_ui.onChanged = (prop_node) => {this.onPropChanged(prop_node);}; // this is ALL WRONG...
                //console.log(this.coloured_ball_tracker_properties.contents_json())

                this.send_message('request_balls', {}) //request balls information.

            }

            on_message_prop(message) {
                console.log(message);
                this.coloured_ball_tracker_properties.set_value_of(message.path, message.value);
                this.properties_ui.update();

            }

            onPropChanged(prop_node) {
                console.log(prop_node.name+' '+prop_node.value());
                this.update_prop(prop_node.path().join('/'), prop_node.value())
            }


            on_message_balls(message) {
                this.update_canvas_size(message.resolution[0], message.resolution[1]);
                //wrap balls up in simple object
                this.balls = message.balls.map(b => {
                    return {
                        id: parseInt(b[0]),
                        colour: b[1],
                        radius: parseFloat(b[2]),
                        x: parseInt(b[3]),
                        y: parseInt(b[4])
                    };
                });

                this.canvas2d.clear();
                this.draw_balls();
                if(this.is_sampling_colour) {
                    if(this.lastHSVHistogram) {
                        const colors = [0, 1,2];
                        colors.forEach((color, index) => {
                            const hist = this.lastHSVHistogram.histogram_hsv[index];
                            this.draw_histogram_hsv(hist, colors[index], this.lastHSVHistogram.pixel_count);

                        })
                    }
                }
            }

            on_message_frame(message) {
                //console.log("image_received");
                let src = false;
                if (message.image.format === "jpg") {
                    src = 'data:image/jpg;base64,' + message.image.data;
                }
                else if (message.image.format === "png") {
                    src = 'data:image/png;base64,' + message.image.data;
                }
                if (src !== false) {
                    this.img.src = src;
                }
                this.is_grabbing_frame = false;
            }

            on_message_sample(message) {
                if(message.event === 'colour') {
                    console.log(message.hsv)
                }
                else if(message.event === 'histogram') {
                    console.log(message.histogram);
                    const colors = [[0,0,255], [0,255,0],[255,0,0]];
                    colors.forEach((color, index) => {
                        const hist = message.histogram[index];
                        this.draw_histogram(hist, colors[index], message.pixel_count);

                    })
                }
                else if(message.event === 'histogram_hsv') {
                    this.lastHSVHistogram = message;
                    //console.log(message.histogram_hsv);
                    const colors = [0, 1,2];
                   // console.log(message.pixel_count);
                    colors.forEach((color, index) => {
                        const hist = message.histogram_hsv[index];
                        this.draw_histogram_hsv(hist, colors[index], message.pixel_count);

                    })
                }
            }


            //https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent
            on_message(message_event) {
                const message_raw = message_event.data;
                let message = null;
                try {
                    message = JSON.parse(message_raw);
                }
                catch (ex) {
                    console.log(ex);
                    console.log(message_raw);
                    return;
                }
                if ("type" in message) {
                    const method_name = "on_message_" + message.type;
                    if (method_name in this) {
                        this[method_name].apply(this, [message])
                    }

                } else {
                    console.log('unknown message :' + message_raw);
                }
            }

            draw_histogram(histogram , colour, pixel_count) {
                for (let index = 0; index < histogram.length-1; index++) {
                    this.canvas2d.line(
                        index, this.hist_map((histogram[index] / pixel_count)),
                        index+1, this.hist_map(histogram[index+1] / pixel_count),
                        colour

                    )

                }
            }

            draw_histogram_hsv(histogram , colour, pixel_count) {
                for (let index = 0; index < histogram.length-1; index++) {
                    let col = [0,255,0];
                    if (colour === 0) { //HUE
                        const hue = (index * 2) / 360.0;
                        col = this.hslToRgb(hue, 1.0, 0.5);
                    } else if (colour === 1) {

                    } else if (colour === 2) {
                        const lum = Math.round((histogram[index] / pixel_count) * 255.0);
                        col = [lum, lum, lum]
                    }

                    this.canvas2d.line(
                        index, this.hist_map(histogram[index] / pixel_count ),
                        index+1, this.hist_map(histogram[index+1] / pixel_count),
                        col

                    )

                }
            }

            hist_map(value) {
                const h = this.canvas2d.height();
                return h - Math.round(value * h);
            }

            hslToRgb(h, s, l){
                let r, g, b;

                if(s === 0){
                    r = g = b = l; // achromatic
                }else{
                    let hue2rgb = function hue2rgb(p, q, t){
                        if(t < 0) t += 1;
                        if(t > 1) t -= 1;
                        if(t < 1/6) return p + (q - p) * 6 * t;
                        if(t < 1/2) return q;
                        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };

                    let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    let p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }

                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }



            draw_balls() {
                this.canvas2d.image(this.img);
                this.balls.forEach(ball => {
                    this.canvas2d.circle(ball.x, ball.y, ball.radius, ball.colour)
                });
            }

            toggle_ui() {
                this.show_ui = !this.show_ui;
                this.update_show_ui();
            }

            update_show_ui() {
                this.send_message("show_ui", {"value": this.show_ui});
            }

            stabilize() {
                this.send_message("stabilize", {"frames": 30});
            }

            update_prop(path, value) {
                this.send_message('prop', {'path': path, 'value': value});
            }

            send_message(type, message = {}) {
                message.type = type;
                console.log('sending '+message.type);
                this.send_json(message);
            }

            id_extra(extra) {
                return (this.id + extra)
            }

            id_as_html(extra = '') {
                return ' id="' + this.id_extra(extra) + '" ';
            }

            setup_dom(parent_element) {
                //  this.parent_element = document.getElementById(parent_id);
                this.element = document.createElement("div");
                this.element.id = this.id_extra('');
                const html = '<div>' +
                    '<canvas ' + this.id_as_html('canvas') + '></canvas>' +
                    '<img ' + this.id_as_html('img') + '>' +
                    '</div>' +
                    '<div>' +
                    '<button ' + this.id_as_html('toggle_ui') + '>Toggle UI</button>' +
                    '<input type="text" value="127.0.0.1"' + this.id_as_html('ip') + '>' +
                    '<button ' + this.id_as_html('connect') + '>Connect</button>' +
                    '<button ' + this.id_as_html('stabilize') + '>Stabilize</button>' +
                    '</div>';
                this.element.innerHTML = html;
               // this.setup_prop_slider('Blur', 'tracker/blur', this.element);
               // this.setup_prop_slider('Quality', 'frame/quality', this.element);

                parent_element.appendChild(this.element);
            }

           /* setup_prop_slider(label, prop_path, parent_element) {
                let wrap = document.createElement("div");
                let html = '<div>' + label + '<div ' + this.id_as_html(prop_path) + '></div></div>';
                wrap.innerHTML = html;
                parent_element.appendChild(wrap);

            }

            connect_prop_slider(prop_path) {
                let id = this.id_extra(prop_path);
                let slider = document.getElementById(id);
                noUiSlider.create(slider, {
                    start: [0],
                    connect: true,
                    step: 1,
                    range: {
                        'min': 0,
                        'max': 100
                    }
                });
                slider.noUiSlider.on('update', (values, handle) => {
                 //   this.quality(values[handle]);
                });
            }*/


        }

        SoundOfColourServer.id_gen = 0; //stupid ES6.0 doesn't easily support class variables
    </script>
    <script>

    </script>

</head>
<body id="body">

</body>
<script>
    const soc = new SoundOfColourServer();
    soc.connect_ui(document.getElementById('body'));
</script>
</html>
