<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sound Of Colour</title>
    <link href="nouislider.min.css" rel="stylesheet">
    <script language="javascript" type="text/javascript">
        class SocketClient {
            constructor(url) {
                this.url = url;  //e.g. "ws://localhost:8001/"
                this.websocket = null;
                this.auto_reconnect = true;
                this.auto_reconnect_interval_id = null;
                this.openHandler = evt => this.on_open(evt);
                this.closeHandler = evt => this.on_close_private(evt);
                this.messageHandler = evt => this.on_message(evt);
                this.errorHandler = evt => this.on_error_private(evt);
            }

            on_open(event) {
                console.log('connection open');
            }

            on_close_private(close_event) {
                console.log('connection closed: ' + close_event.code + ' ' + close_event.reason);
                this.update_auto_reconnect();
                this.on_close(close_event);
            }

            on_close(close_event) {

            }

            on_message(message_event) {
                console.log('message received. size:' + message_event.data.length);
            }

            on_error_private(error_event) {
                this.update_auto_reconnect();
                this.on_error(error_event);
            }

            on_error(event) {
                console.log('connection error: ' + event.type);
            }

            is_connected() {
                if (this.websocket !== null) {
                    return (this.websocket.readyState === this.websocket.OPEN);
                }
            }

            disconnected() {
                this.disconnect_handlers();
                this.websocket.close();
                this.websocket = null;
            }

            close() {
                if (this.is_connected()) {
                    this.disconnected();
                }
            }

            update_auto_reconnect() {
                this.disconnected();
                if (this.auto_reconnect) {
                    console.log('will attempt reconnect in 1 second');
                    this.auto_reconnect_interval_id = setInterval(() => this.start_connect(), 1000)
                }
            }

            stop_auto_reconnect() {
                clearInterval(this.auto_reconnect_interval_id);
                this.auto_reconnect_interval_id = null;
            }

            connect_handlers() {
                this.websocket.addEventListener('open', this.openHandler);
                this.websocket.addEventListener('close', this.closeHandler);
                this.websocket.addEventListener('message', this.messageHandler);
                this.websocket.addEventListener('error', this.errorHandler);
            }

            disconnect_handlers() {
                this.websocket.removeEventListener('open', this.openHandler);
                this.websocket.removeEventListener('close', this.closeHandler);
                this.websocket.removeEventListener('message', this.messageHandler);
                this.websocket.removeEventListener('error', this.errorHandler);
            }

            send_raw(message) {
                if (this.is_connected()) {
                    this.websocket.send(message); //todo: probably has some errors it can throw
                }
            }

            send_json(message) {
                this.send_raw(JSON.stringify(message));
            }

            start_connect() {
                console.log("Connecting...");
                this.stop_auto_reconnect();
                try {
                    this.websocket = new WebSocket(this.url);
                } catch (ex) {
                    console.log(ex + ' port probably closed');
                    this.websocket = null;
                    return;
                }
                this.connect_handlers();
            }
        }
    </script>
    <script language="javascript" type="text/javascript">
        class Canvas2D {
            constructor(dom_id = null) {
                this.ctx = null;
                if (dom_id !== null) {
                    let element = document.getElementById(dom_id);
                    if (element !== null) {
                        if (element.nodeName.toLowerCase() === 'canvas') {
                            this.connect_to_canvas(element);
                        }
                    }
                }
            }

            connect_to_canvas(canvas_element) {
                this.canvas = canvas_element;
                this.ctx = this.canvas.getContext("2d");
            }

            ready() {
                return (this.ctx !== null);
            }

            clear() {
                if (!this.ready()) return; //todo implement as empty functions?
                this.ctx.fillStyle = "black";
                //ctx.fillRect(0,0,300,150);
                this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
            }

            disc(x, y, radius, colour) {
                if (!this.ready()) return; //todo implement as empty functions?
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius, 0, 2 * Math.PI, false);
                this.ctx.fillStyle = colour;
                this.ctx.fill();
            }

            update_resolution(width, height) {
                if (
                    (width !== this.canvas.width) ||
                    (height !== this.canvas.height)) {
                    this.canvas.width = width;
                    this.canvas.height = height;
                }
            }
        }

    </script>

    <script language="javascript" type="text/javascript">
        class SoundOfColourServer extends SocketClient {
            constructor(url, canvasID, imageID) {
                super(url);
                this.balls = [];
                this.resolution = {width: 0, height: 0};
                /*@var Canvas2D */
                this.canvas2d = new Canvas2D(canvasID);
                this.img = document.getElementById(imageID);
                this.show_ui = false;
                this.frame_quality = 30;
                this.frame_grabber_id = null;
                this.is_grabbing_frame = false;

                this.message_handlers = {
                    welcome: this.on_message_welcome,
                    balls: this.on_message_balls,
                    frame: this.on_message_frame
                }
            }

            on_open(event) {
                this.frame_grabber_id = setInterval(() => this.maybe_request_frame(), 20);
            }

            quality(q) {
                this.frame_quality = parseInt(q);
            }

            maybe_request_frame() {
                if (this.is_connected()) {
                    //console.log('request a frame');
                    if (this.is_grabbing_frame === false) {
                        this.is_grabbing_frame = true;
                        this.send_message("frame",
                            {
                                'quality': this.frame_quality, 'format': 'jpg', ratio: 1.0
                            });
                        return;
                    } else {
                        //console.log('Bounced');
                    }
                }
                this.is_grabbing_frame = false;
            }

            update_canvas_size(width, height) {
                this.resolution.width = width;
                this.resolution.height = height;
                this.canvas2d.update_resolution(width, height);
            }

            on_message_welcome() {
                this.update_show_ui();
            }

            on_message_balls(message) {
                this.update_canvas_size(message.resolution[0], message.resolution[1]);
                //wrap balls up in simple object
                this.balls = message.balls.map(b => {
                    return {
                        id: parseInt(b[0]),
                        colour: b[1],
                        radius: parseFloat(b[2]),
                        x: parseInt(b[3]),
                        y: parseInt(b[4])
                    };
                });

                this.canvas2d.clear();
                this.draw_balls()
            }

            on_message_frame(message) {
                //console.log("image_received");
                let src = false;
                if (message.image.format === "jpg") {
                    src = 'data:image/jpg;base64,' + message.image.data;
                }
                else if (message.image.format === "png") {
                    src = 'data:image/png;base64,' + message.image.data;
                }
                if (src !== false) {
                    this.img.src = src;
                }
                this.is_grabbing_frame = false;
            }


            //https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent
            on_message(message_event) {
                const message_raw = message_event.data;
                const message = JSON.parse(message_raw);
                if ("type" in message) {
                    if (message.type in this.message_handlers) {
                        this.message_handlers[message.type].apply(this, [message]);
                    }
                } else {
                    console.log('unknown message :'+message_raw);
                }
            }

            draw_balls() {
                this.balls.forEach(ball => {
                    this.canvas2d.disc(ball.x, ball.y, ball.radius, ball.colour)
                });
            }

            toggle_ui() {
                this.show_ui = !this.show_ui;
                this.update_show_ui();
            }

            update_show_ui() {
                this.send_message("show_ui", {"value": this.show_ui});
            }

            stabilize() {
                this.send_message("stabilize", {"frames": 30});
            }

            update_prop(path, value) {
                this.send_message('prop', {'path': path, 'value': value});
            }

            send_message(type, message) {
                message.type = type;
                this.send_json(message);
            }


        }


    </script>

</head>
<body>
<div>
    <div>
        <canvas id="frame1"></canvas>
        <img id="test1">
    </div>
    <button onclick="soc1.toggle_ui()">Toggle UI</button>
    <input type="text" value="127.0.0.1" id="ip1">
    <button onclick="connect(1)">Connect</button>
    <button onclick="stabilize(1)">Stabilize</button>
    <div>Blur:
        <div id="1:tracker/blur"></div>
    </div>
    <div>Quality:
        <div id="1:frame/quality"></div>
    </div>
</div>
<div>
    <div>
        <canvas id="frame2"></canvas>
        <img id="test2">
    </div>
    <button onclick="soc2.toggle_ui()">Toggle UI</button>
    <input type="text" value="172.30.68.142" id="ip2">
    <button onclick="connect(2)">Connect</button>
    <button onclick="stabilize(2)">Stabilize</button>
    <div>Quality:
        <div id="2:frame/quality"></div>
    </div>
</div>
<script src="nouislider.min.js"></script>
<script>
    //ws://
    let soc1 = null;
    let soc2 = null;

    function connect(index) {
        let ip = document.getElementById('ip' + index);
        let soc = soc1;
        if (index === 2) {
            soc = soc2;
        }
        if (soc !== null) {
            soc.close();
        }
        soc = new SoundOfColourServer("ws://" + ip.value + ":8001", 'frame' + index, 'test' + index);
        soc.start_connect();
        if (index === 1) {
            soc1 = soc;
        } else {
            soc2 = soc;
        }
    }

    function stabilize(index) {
        let soc = soc1;
        if (index === 2) {
            soc = soc2;
        }
        soc.stabilize();
    }

    let slider = document.getElementById("1:tracker/blur");
    noUiSlider.create(slider, {
        start: [0],
        connect: true,
        step: 1,
        range: {
            'min': 0,
            'max': 100
        }
    });
    slider.noUiSlider.on('update', function (values, handle) {
        //inputFormat.value = values[handle];
        if (soc1 !== null) {
            soc1.update_prop('tracker/blur', parseInt(values[handle]));
        }
    });


    let slider2 = document.getElementById("1:frame/quality");
    noUiSlider.create(slider2, {
        start: [0],
        connect: true,
        step: 1,
        range: {
            'min': 0,
            'max': 100
        }
    });
    slider2.noUiSlider.on('update', function (values, handle) {
        //inputFormat.value = values[handle];
        if (soc1 !== null) {
            soc1.quality(values[handle]);
        }
    });


    let slider3 = document.getElementById("2:frame/quality");
    noUiSlider.create(slider3, {
        start: [0],
        connect: true,
        step: 1,
        range: {
            'min': 0,
            'max': 100
        }
    });
    slider3.noUiSlider.on('update', function (values, handle) {
        //inputFormat.value = values[handle];
        if (soc2 !== null) {
            soc2.quality(values[handle]);
        }
    });


</script>


</body>
</html>
